"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Registry = void 0;

var _counter = require("./counter");

var _gauge = require("./gauge");

var _histogram = require("./histogram");

var _utils = require("./utils");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Registry =
/*#__PURE__*/
function () {
  function Registry() {
    _classCallCheck(this, Registry);

    _defineProperty(this, "data", void 0);

    this.data = {
      counter: {},
      gauge: {},
      histogram: {}
    };
  }

  _createClass(Registry, [{
    key: "validateInput",
    value: function validateInput(type, name, help, buckets) {
      // checks for js runtime
      if (String(name) === '') {
        throw new Error('Metric name cannot be empty');
      }

      if (['counter', 'gauge', 'histogram'].indexOf(type) === -1) {
        throw new Error("Unknown metric type ".concat(type));
      }

      if (typeof help !== 'string' && help != null) {
        throw new Error('help must be string or undefined/null');
      }

      if (this.data[type][name]) {
        throw new Error("A metric with the name '".concat(name, "' already exists for type '").concat(type, "'"));
      }

      if (!Array.isArray(buckets) && buckets != null) {
        throw new Error('buckets must be array or undefined/null');
      }
    }
  }, {
    key: "create",
    value: function create(type, name) {
      var help = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var histogramBuckets = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      this.validateInput(type, name, help, histogramBuckets);
      var instance;

      if (type === 'counter') {
        instance = new _counter.Counter();
        this.data.counter[name] = {
          help: help,
          instance: instance,
          type: type
        };
      } else if (type === 'gauge') {
        instance = new _gauge.Gauge();
        this.data.gauge[name] = {
          help: help,
          instance: instance,
          type: type
        };
      } else {
        instance = new _histogram.Histogram(histogramBuckets);
        this.data.histogram[name] = {
          help: help,
          instance: instance,
          type: type
        };
      }

      return instance;
    }
    /**
     * Returns a string in the prometheus' desired format
     * More info: https://prometheus.io/docs/concepts/data_model/
     * Loop through each metric type (counter, histogram, etc);
     *
     * @return {string}
     */

  }, {
    key: "metrics",
    value: function metrics() {
      return Object.entries(this.data).reduce(function (out, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            type = _ref2[0],
            metrics = _ref2[1];

        return out + Object.entries(metrics).reduce(function (src, _ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              name = _ref4[0],
              metric = _ref4[1];

          var values = metric.instance.collect();
          var result = src;

          if (metric.help.length > 0) {
            result += "# HELP ".concat(name, " ").concat(metric.help, "\n");
          }

          result += "# TYPE ".concat(name, " ").concat(type, "\n"); // Each metric can have many labels. Iterate over each and append to the string.

          result += values.reduce(function (str, value) {
            var formatted = type === 'histogram' ? (0, _utils.formatHistogramOrSummary)(name, value) : (0, _utils.formatCounterOrGauge)(name, value);
            return str + formatted;
          }, '');
          return result;
        }, '');
      }, '');
    }
  }, {
    key: "reset",
    value: function reset() {
      Object.values(this.data).map(function (m) {
        return Object.values(m).map(function (_ref5) {
          var instance = _ref5.instance;
          return instance.resetAll();
        });
      });
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.data = {
        counter: {},
        gauge: {},
        histogram: {}
      };
      return this;
    }
  }, {
    key: "get",
    value: function get(type, name) {
      var registryItems = type != null ? [this.data[type]] : Object.values(this.data);
      var metric = registryItems.find(function (v) {
        return name in v;
      });
      return metric != null ? metric[name].instance : undefined;
    }
  }]);

  return Registry;
}();

exports.Registry = Registry;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZWdpc3RyeS50cyJdLCJuYW1lcyI6WyJSZWdpc3RyeSIsImRhdGEiLCJjb3VudGVyIiwiZ2F1Z2UiLCJoaXN0b2dyYW0iLCJ0eXBlIiwibmFtZSIsImhlbHAiLCJidWNrZXRzIiwiU3RyaW5nIiwiRXJyb3IiLCJpbmRleE9mIiwiQXJyYXkiLCJpc0FycmF5IiwiaGlzdG9ncmFtQnVja2V0cyIsInZhbGlkYXRlSW5wdXQiLCJpbnN0YW5jZSIsIkNvdW50ZXIiLCJHYXVnZSIsIkhpc3RvZ3JhbSIsIk9iamVjdCIsImVudHJpZXMiLCJyZWR1Y2UiLCJvdXQiLCJtZXRyaWNzIiwic3JjIiwibWV0cmljIiwidmFsdWVzIiwiY29sbGVjdCIsInJlc3VsdCIsImxlbmd0aCIsInN0ciIsInZhbHVlIiwiZm9ybWF0dGVkIiwibWFwIiwibSIsInJlc2V0QWxsIiwicmVnaXN0cnlJdGVtcyIsImZpbmQiLCJ2IiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWdCYUEsUTs7O0FBS1gsc0JBQWM7QUFBQTs7QUFBQTs7QUFDWixTQUFLQyxJQUFMLEdBQVk7QUFDVkMsTUFBQUEsT0FBTyxFQUFFLEVBREM7QUFFVkMsTUFBQUEsS0FBSyxFQUFFLEVBRkc7QUFHVkMsTUFBQUEsU0FBUyxFQUFFO0FBSEQsS0FBWjtBQUtEOzs7O2tDQUdDQyxJLEVBQ0FDLEksRUFDQUMsSSxFQUNBQyxPLEVBQ007QUFDTjtBQUNBLFVBQUlDLE1BQU0sQ0FBQ0gsSUFBRCxDQUFOLEtBQWlCLEVBQXJCLEVBQXlCO0FBQ3ZCLGNBQU0sSUFBSUksS0FBSixDQUFVLDZCQUFWLENBQU47QUFDRDs7QUFDRCxVQUFJLENBQUMsU0FBRCxFQUFZLE9BQVosRUFBcUIsV0FBckIsRUFBa0NDLE9BQWxDLENBQTBDTixJQUExQyxNQUFvRCxDQUFDLENBQXpELEVBQTREO0FBQzFELGNBQU0sSUFBSUssS0FBSiwrQkFB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QixDQUFmO0FBRUEsYUFBT2IsTUFBTSxJQUFJLElBQVYsR0FBaUJBLE1BQU0sQ0FBQ3BCLElBQUQsQ0FBTixDQUFhVSxRQUE5QixHQUF5Q3dCLFNBQWhEO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2xsZWN0b3IgfSBmcm9tICcuL2NvbGxlY3Rvcic7XG5pbXBvcnQgeyBDb3VudGVyIH0gZnJvbSAnLi9jb3VudGVyJztcbmltcG9ydCB7IEdhdWdlIH0gZnJvbSAnLi9nYXVnZSc7XG5pbXBvcnQgeyBIaXN0b2dyYW0gfSBmcm9tICcuL2hpc3RvZ3JhbSc7XG5pbXBvcnQgeyBDb2xsZWN0b3JUeXBlLCBDb3VudGVyVmFsdWUsIEhpc3RvZ3JhbVZhbHVlLCBNZXRyaWMgfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHsgZm9ybWF0Q291bnRlck9yR2F1Z2UsIGZvcm1hdEhpc3RvZ3JhbU9yU3VtbWFyeSB9IGZyb20gJy4vdXRpbHMnO1xuXG50eXBlIENvbGxlY3RvckZvclR5cGU8VCBleHRlbmRzIENvbGxlY3RvclR5cGU+ID1cbiAgVCBleHRlbmRzICdoaXN0b2dyYW0nID8gSGlzdG9ncmFtIDpcbiAgICBUIGV4dGVuZHMgJ2dhdWdlJyA/IEdhdWdlIDpcbiAgICAgIFQgZXh0ZW5kcyAnY291bnRlcicgPyBDb3VudGVyIDpcbiAgICAgICAgbmV2ZXI7XG5cbmludGVyZmFjZSBSZWdpc3RyeUl0ZW08VCBleHRlbmRzIENvbGxlY3RvclR5cGU+IHtcbiAgW2tleTogc3RyaW5nXToge1xuICAgIHR5cGU6IFQ7XG4gICAgaGVscDogc3RyaW5nO1xuICAgIGluc3RhbmNlOiBDb2xsZWN0b3JGb3JUeXBlPFQ+O1xuICB9O1xufVxuXG5leHBvcnQgY2xhc3MgUmVnaXN0cnkge1xuICBwcml2YXRlIGRhdGE6IHtcbiAgICBbSyBpbiBDb2xsZWN0b3JUeXBlXTogUmVnaXN0cnlJdGVtPEs+XG4gIH07XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgY291bnRlcjoge30sXG4gICAgICBnYXVnZToge30sXG4gICAgICBoaXN0b2dyYW06IHt9XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVJbnB1dChcbiAgICB0eXBlOiBDb2xsZWN0b3JUeXBlLFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBoZWxwPzogc3RyaW5nLFxuICAgIGJ1Y2tldHM/OiBudW1iZXJbXSxcbiAgKTogdm9pZCB7XG4gICAgLy8gY2hlY2tzIGZvciBqcyBydW50aW1lXG4gICAgaWYgKFN0cmluZyhuYW1lKSA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0cmljIG5hbWUgY2Fubm90IGJlIGVtcHR5Jyk7XG4gICAgfVxuICAgIGlmIChbJ2NvdW50ZXInLCAnZ2F1Z2UnLCAnaGlzdG9ncmFtJ10uaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBtZXRyaWMgdHlwZSAke3R5cGV9YCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoZWxwICE9PSAnc3RyaW5nJyAmJiBoZWxwICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaGVscCBtdXN0IGJlIHN0cmluZyBvciB1bmRlZmluZWQvbnVsbCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRhdGFbdHlwZV1bbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQSBtZXRyaWMgd2l0aCB0aGUgbmFtZSAnJHtuYW1lfScgYWxyZWFkeSBleGlzdHMgZm9yIHR5cGUgJyR7dHlwZX0nYCk7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGJ1Y2tldHMpICYmIGJ1Y2tldHMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWNrZXRzIG11c3QgYmUgYXJyYXkgb3IgdW5kZWZpbmVkL251bGwnKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGUodHlwZTogJ2NvdW50ZXInLCBuYW1lOiBzdHJpbmcsIGhlbHA/OiBzdHJpbmcpOiBDb3VudGVyO1xuXG4gIGNyZWF0ZSh0eXBlOiAnZ2F1Z2UnLCBuYW1lOiBzdHJpbmcsIGhlbHA/OiBzdHJpbmcpOiBHYXVnZTtcblxuICBjcmVhdGUodHlwZTogJ2hpc3RvZ3JhbScsIG5hbWU6IHN0cmluZywgaGVscD86IHN0cmluZywgaGlzdG9ncmFtQnVja2V0cz86IG51bWJlcltdKTogSGlzdG9ncmFtO1xuXG4gIGNyZWF0ZShcbiAgICB0eXBlOiBDb2xsZWN0b3JUeXBlLFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBoZWxwID0gJycsXG4gICAgaGlzdG9ncmFtQnVja2V0czogbnVtYmVyW10gPSBbXSxcbiAgKTogQ29sbGVjdG9yPGFueT4ge1xuICAgIHRoaXMudmFsaWRhdGVJbnB1dCh0eXBlLCBuYW1lLCBoZWxwLCBoaXN0b2dyYW1CdWNrZXRzKTtcblxuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAodHlwZSA9PT0gJ2NvdW50ZXInKSB7XG4gICAgICBpbnN0YW5jZSA9IG5ldyBDb3VudGVyKCk7XG4gICAgICB0aGlzLmRhdGEuY291bnRlcltuYW1lXSA9IHsgaGVscCwgaW5zdGFuY2UsIHR5cGUgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdnYXVnZScpIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IEdhdWdlKCk7XG4gICAgICB0aGlzLmRhdGEuZ2F1Z2VbbmFtZV0gPSB7IGhlbHAsIGluc3RhbmNlLCB0eXBlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IEhpc3RvZ3JhbShoaXN0b2dyYW1CdWNrZXRzKTtcbiAgICAgIHRoaXMuZGF0YS5oaXN0b2dyYW1bbmFtZV0gPSB7IGhlbHAsIGluc3RhbmNlLCB0eXBlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgaW4gdGhlIHByb21ldGhldXMnIGRlc2lyZWQgZm9ybWF0XG4gICAqIE1vcmUgaW5mbzogaHR0cHM6Ly9wcm9tZXRoZXVzLmlvL2RvY3MvY29uY2VwdHMvZGF0YV9tb2RlbC9cbiAgICogTG9vcCB0aHJvdWdoIGVhY2ggbWV0cmljIHR5cGUgKGNvdW50ZXIsIGhpc3RvZ3JhbSwgZXRjKTtcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgbWV0cmljcygpOiBzdHJpbmcge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLmRhdGEpLnJlZHVjZShcbiAgICAgIChvdXQsIFt0eXBlLCBtZXRyaWNzXSkgPT4gb3V0ICsgT2JqZWN0LmVudHJpZXMobWV0cmljcykucmVkdWNlKChzcmMsIFtuYW1lLCBtZXRyaWNdKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG1ldHJpYy5pbnN0YW5jZS5jb2xsZWN0KCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBzcmM7XG4gICAgICAgIGlmIChtZXRyaWMuaGVscC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAjIEhFTFAgJHtuYW1lfSAke21ldHJpYy5oZWxwfVxcbmA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGAjIFRZUEUgJHtuYW1lfSAke3R5cGV9XFxuYDtcbiAgICAgICAgLy8gRWFjaCBtZXRyaWMgY2FuIGhhdmUgbWFueSBsYWJlbHMuIEl0ZXJhdGUgb3ZlciBlYWNoIGFuZCBhcHBlbmQgdG8gdGhlIHN0cmluZy5cbiAgICAgICAgcmVzdWx0ICs9IHZhbHVlcy5yZWR1Y2UoKHN0cjogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gdHlwZSA9PT0gJ2hpc3RvZ3JhbSdcbiAgICAgICAgICAgID8gZm9ybWF0SGlzdG9ncmFtT3JTdW1tYXJ5KG5hbWUsIHZhbHVlIGFzIE1ldHJpYzxIaXN0b2dyYW1WYWx1ZT4pXG4gICAgICAgICAgICA6IGZvcm1hdENvdW50ZXJPckdhdWdlKG5hbWUsIHZhbHVlIGFzIE1ldHJpYzxDb3VudGVyVmFsdWU+KTtcbiAgICAgICAgICByZXR1cm4gc3RyICsgZm9ybWF0dGVkO1xuICAgICAgICB9LCAnJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCAnJyksXG4gICAgICAnJ1xuICAgICk7XG4gIH1cblxuICByZXNldCgpOiB0aGlzIHtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuZGF0YSkubWFwKG0gPT4gT2JqZWN0LnZhbHVlcyhtKS5tYXAoKHsgaW5zdGFuY2UgfSkgPT4gaW5zdGFuY2UucmVzZXRBbGwoKSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xlYXIoKTogdGhpcyB7XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgY291bnRlcjoge30sXG4gICAgICBnYXVnZToge30sXG4gICAgICBoaXN0b2dyYW06IHt9LFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCh0eXBlOiAnY291bnRlcicsIG5hbWU6IHN0cmluZyk6IENvdW50ZXIgfCB1bmRlZmluZWQ7XG5cbiAgZ2V0KHR5cGU6ICdnYXVnZScsIG5hbWU6IHN0cmluZyk6IEdhdWdlIHwgdW5kZWZpbmVkO1xuXG4gIGdldCh0eXBlOiAnaGlzdG9ncmFtJywgbmFtZTogc3RyaW5nKTogSGlzdG9ncmFtIHwgdW5kZWZpbmVkO1xuXG4gIGdldCh0eXBlOiBDb2xsZWN0b3JUeXBlLCBuYW1lOiBzdHJpbmcpOiBDb2xsZWN0b3I8YW55PiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcmVnaXN0cnlJdGVtcyA9IHR5cGUgIT0gbnVsbCA/IFt0aGlzLmRhdGFbdHlwZV1dIDogT2JqZWN0LnZhbHVlcyh0aGlzLmRhdGEpO1xuICAgIGNvbnN0IG1ldHJpYyA9IHJlZ2lzdHJ5SXRlbXMuZmluZCh2ID0+IG5hbWUgaW4gdik7XG5cbiAgICByZXR1cm4gbWV0cmljICE9IG51bGwgPyBtZXRyaWNbbmFtZV0uaW5zdGFuY2UgOiB1bmRlZmluZWQ7XG4gIH1cbn1cbiJdfQ==