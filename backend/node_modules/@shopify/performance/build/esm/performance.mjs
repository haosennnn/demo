import { onTTFB, onFCP, onFID, onLCP } from 'web-vitals';
import { InflightNavigation } from './inflight.mjs';
import { hasGlobal, referenceTime, supportsPerformanceObserver, withNavigation, withTiming, withEntriesOfType, now, getResourceTypeFromEntry } from './utilities.mjs';
import { EventType } from './types.mjs';

const WATCH_RESOURCE_TYPES = ['script', 'css', 'link'];
const DEFAULT_TIMEOUT = 60000;
class Performance {
  constructor() {
    this.supportsObserver = hasGlobal('PerformanceObserver');
    this.supportsMarks = hasGlobal('PerformanceMark');
    this.supportsNavigationEntries = hasGlobal('PerformanceNavigationTiming');
    this.supportsTimingEntries = hasGlobal('PerformanceTiming');
    this.supportsLongtaskEntries = hasGlobal('PerformanceLongTaskTiming');
    this.supportsResourceEntries = hasGlobal('PerformanceResourceTiming');
    this.supportsPaintEntries = hasGlobal('PerformancePaintTiming');
    this.timeOrigin = referenceTime();
    this.supportsDetailedTime = supportsPerformanceObserver;
    this.supportsDetailedEvents = this.supportsNavigationEntries && this.supportsLongtaskEntries && this.supportsResourceEntries && this.supportsPaintEntries;
    this.lifecycleEvents = [];
    this.navigationCount = 0;
    this.eventHandlers = {
      navigation: new Set(),
      inflightNavigation: new Set(),
      lifecycleEvent: new Set()
    };
    this.start({
      timeStamp: 0
    });
    withNavigation(this.start.bind(this));

    if (this.supportsTimingEntries && (!this.supportsDetailedTime || !this.supportsNavigationEntries)) {
      withTiming(({
        domContentLoadedEventStart,
        loadEventStart
      }) => {
        // window.performance.timing uses full timestamps, while
        // the ones coming from observing navigation entries are
        // time from performance.timeOrigin. We just normalize these
        // ones to be relative to "start" since things listening for
        // events expect them to be relative to when the navigation
        // began.
        this.lifecycleEvent({
          type: EventType.DomContentLoaded,
          start: domContentLoadedEventStart - this.timeOrigin,
          duration: 0
        });
        this.lifecycleEvent({
          type: EventType.Load,
          start: loadEventStart - this.timeOrigin,
          duration: 0
        });
      });
    } else {
      withEntriesOfType('navigation', entry => {
        if (entry.domContentLoadedEventStart > 0) {
          this.lifecycleEvent({
            type: EventType.DomContentLoaded,
            start: entry.domContentLoadedEventStart,
            duration: 0
          });
        }

        if (entry.loadEventStart > 0) {
          this.lifecycleEvent({
            type: EventType.Load,
            start: entry.loadEventStart,
            duration: 0
          });
        }
      });
    }

    if (this.supportsResourceEntries) {
      withEntriesOfType('resource', entry => {
        if (!WATCH_RESOURCE_TYPES.includes(entry.initiatorType)) {
          return;
        }

        const type = getResourceTypeFromEntry(entry);

        if (type === 'unsupported') {
          return;
        }

        this.event({
          type,
          start: entry.startTime,
          duration: entry.duration,
          metadata: {
            name: entry.name,
            size: entry.encodedBodySize
          }
        }, {
          replace: true
        });
      });
    }

    if (this.supportsLongtaskEntries) {
      withEntriesOfType('longtask', entry => {
        this.event({
          type: EventType.LongTask,
          start: entry.startTime,
          duration: entry.duration
        });
      });
    }

    if (this.supportsPaintEntries) {
      withEntriesOfType('paint', entry => {
        if (entry.name === 'first-paint') {
          this.lifecycleEvent({
            type: EventType.TimeToFirstPaint,
            start: entry.startTime,
            duration: 0
          });
        }
      });
    }

    onTTFB(metric => {
      this.lifecycleEvent({
        type: EventType.TimeToFirstByte,
        start: metric.value,
        duration: 0
      });
    });
    onFCP(metric => {
      this.lifecycleEvent({
        type: EventType.TimeToFirstContentfulPaint,
        start: metric.value,
        duration: 0
      });
    });
    onFID(metric => {
      this.lifecycleEvent({
        type: EventType.FirstInputDelay,
        start: now() - metric.value,
        duration: metric.value
      });
    });
    onLCP(metric => {
      this.lifecycleEvent({
        type: EventType.TimeToLargestContentfulPaint,
        start: metric.value,
        duration: 0
      });
    });
  }

  mark(stage, id) {
    if (this.supportsMarks) {
      window.performance.mark(`${id}::${stage}`);
    }
  }

  on(event, handler) {
    const handlers = this.eventHandlers[event];
    handlers.add(handler); // If they are registering to hear about completed navigations, and we have already
    // completed the first load, tell them about it. This allows them to bind to the
    // listener later and still feel as if they had registered as early as possible.

    if (event === 'navigation' && this.firstNavigation != null && this.navigationCount === 1) {
      handler(this.firstNavigation);
    } // If they are registered to hear about new navigations, and one is in flight,
    // tell them right away.


    if (event === 'inflightNavigation' && this.inflightNavigation != null) {
      handler();
    }

    if (event === 'lifecycleEvent') {
      for (const event of this.lifecycleEvents) {
        handler(event);
      }
    }

    return () => handlers.delete(handler);
  }

  event(event, {
    replace = false
  } = {}) {
    if (this.inflightNavigation == null) {
      return;
    }

    this.inflightNavigation.event(event, replace);
  }

  start({
    timeStamp = now(),
    target = window.location.pathname,
    timeout = DEFAULT_TIMEOUT
  } = {}) {
    this.clearTimeout();

    if (this.inflightNavigation) {
      this.record(this.inflightNavigation.cancel(timeStamp));
    }

    this.inflightNavigation = new InflightNavigation({
      timeOrigin: this.timeOrigin,
      start: timeStamp,
      target
    }, {
      index: this.navigationCount,
      supportsDetailedTime: this.supportsDetailedTime,
      supportsDetailedEvents: this.supportsDetailedEvents
    });
    this.navigationTimeout = setTimeout(() => this.timeout.bind(this), timeout);

    for (const subscriber of this.eventHandlers.inflightNavigation) {
      subscriber();
    }
  }

  usable(timeStamp = now()) {
    this.event({
      type: EventType.Usable,
      start: timeStamp,
      duration: 0
    }, {
      replace: true
    });
  }

  finish(timeStamp = now()) {
    this.clearTimeout();

    if (this.inflightNavigation == null) {
      return;
    }

    const navigation = this.inflightNavigation.finish(timeStamp);
    this.firstNavigation = this.firstNavigation || navigation;
    this.record(navigation);
    this.inflightNavigation = undefined;
  }

  lifecycleEvent(event) {
    if (this.lifecycleEvents.find(({
      type
    }) => type === event.type) != null) {
      return;
    } // In some cases the value reported is negative. Ignore these cases:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1429422#c12
    // https://github.com/GoogleChrome/web-vitals/issues/137


    if (event.start < 0) return;
    this.event(event);
    this.lifecycleEvents.push(event);

    for (const handler of this.eventHandlers.lifecycleEvent) {
      handler(event);
    }
  }

  timeout() {
    this.clearTimeout();

    if (this.inflightNavigation == null) {
      return;
    }

    this.record(this.inflightNavigation.timeout());
  }

  clearTimeout() {
    if (this.navigationTimeout) {
      clearTimeout(this.navigationTimeout);
      this.navigationTimeout = undefined;
    }
  }

  record(navigation) {
    this.navigationCount += 1;

    for (const subscriber of this.eventHandlers.navigation) {
      subscriber(navigation);
    }
  }

}

export { Performance };
